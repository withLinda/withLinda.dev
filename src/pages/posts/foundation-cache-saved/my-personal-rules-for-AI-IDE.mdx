---
layout: ../../../layouts/BlogPost.astro
title: "My Personal Rules for AI IDE"
description: "A guide to documenting comments for React and TypeScript code, featuring operator terminology, proper commenting practices, and TypeScript-specific documentation patterns"
pubDate: "2025-01-08"
heroImage: "https://images.unsplash.com/photo-1555066931-4365d14bab8c?auto=format&fit=crop&q=80"

---

import Gist from '@kotosha/astro-gist';

<Gist id="4aeccbe1dbaa7f89c182bd65d2764203" />

### Comment Guide for AI Development with React and TypeScript

This is a comprehensive guide for AI tools to understand and generate proper comments in React and TypeScript projects. The guide includes operator terminology, documentation patterns, and best practices for code commenting.

```markdown

# I'm using Windows operating system and Powershell

#Please do NOT be lazy, if you suggest a fix of a file, rewrite the codes without truncation, do not use something like [existing]  [... Continue with more sections and images ...] or [... Continue with existing codes ...], etc.

# React & TypeScript Code Documentation Guide

Use these specific terms when commenting code to make documentation searchable and consistent.

## Operators & Expressions

### Conditional Operators

- `? :` - **Ternary Conditional Operator**
- `&&` - **Logical AND Operator** (short-circuit evaluation)
- `||` - **Logical OR Operator** (short-circuit evaluation)
- `??` - **Nullish Coalescing Operator**

### Optional Chaining

- `?.` - **Optional Chaining Operator**
- `!.` - **Non-null Assertion Operator**

### Type Operations

- `as` - **Type Assertion Operator**
- `instanceof` - **Instance Check Operator**
- `typeof` - **Type Check Operator**
- `keyof` - **Index Type Query Operator**

### String Operations

- `+` - **String Concatenation Operator**
- `` ` `` - **Template Literal**
- `${expression}` - **String Interpolation**

### Array Operations

- `...` - **Spread Operator**
- `.map()` - **Array Mapping Method**
- `.filter()` - **Array Filter Method**
- `.reduce()` - **Array Reduction Method**
- `.find()` - **Array Find Method**

### Object Operations

- `...` - **Object Spread Operator**
- `?.` - **Optional Property Access**
- `??=` - **Nullish Coalescing Assignment**

### React-Specific

- `<>` - **Fragment Shorthand**
- `React.Fragment` - **Fragment Component**
- `useState` - **State Hook**
- `useEffect` - **Effect Hook**
- `useMemo` - **Memoization Hook**
- `useCallback` - **Callback Memoization Hook**

### TypeScript-Specific

- `interface` - **Interface Declaration**
- `type` - **Type Alias**
- `extends` - **Type Extension**
- `implements` - **Interface Implementation**
- `&` - **Intersection Type Operator**
- `|` - **Union Type Operator**

## Example Usage in Comments

```typescript
// Using Nullish Coalescing Operator (??) for default value
const value = data ?? defaultValue;

// Using Optional Chaining Operator (?.) for safe property access
const userName = user?.profile?.name;

// Using Ternary Conditional Operator (? :) for conditional rendering
const element = isLoading ? <Loading /> : <Content />;

// Using Logical AND Operator (&&) for conditional rendering
{
  isVisible && <Component />;
}

// Using Template Literal (``) with String Interpolation (${})
const greeting = `Hello, ${userName}!`;

// Using Array Spread Operator (...) for array copying
const newArray = [...existingArray];

// Using Type Assertion Operator (as) for type casting
const element = event.target as HTMLInputElement;

// Using Union Type Operator (|) for multiple types
type Status = "loading" | "success" | "error";


## Style Guide for Comments

1. Be specific with operator names
2. Include both the symbol and the full operator name
3. Mention the purpose after the operator specification
4. Keep comments concise but descriptive

Example:

```typescript
// Ternary Operator (? :) - Conditionally assigns role based on admin status
const role = isAdmin ? "administrator" : "user";
```


### From: Reddit thread "[Pro Tip: These 3 Magic Words Will Make Claude Write WAY Better Code (KISS, YAGNI, SOLID)](https://www.reddit.com/r/ClaudeAI/comments/1gqcsn6/pro_tip_these_3_magic_words_will_make_claude/?share_id=DBbQj_iX-kJQcHuf2sg11&utm_content=1&utm_medium=android_app&utm_name=androidcss&utm_source=share&utm_term=1)"

```
Follow these principles:

KISS (Keep It Simple, Stupid)
Encourages Claude to write straightforward, uncomplicated solutions
Avoids over-engineering and unnecessary complexity
Results in more readable and maintainable code

YAGNI (You Aren't Gonna Need It)
Prevents Claude from adding speculative features
Focuses on implementing only what's currently needed
Reduces code bloat and maintenance overhead

SOLID Principles
Single Responsibility Principle
Open-Closed Principle
Liskov Substitution Principle
Interface Segregation Principle
Dependency Inversion Principle


// Define core principles
define KISS as "Keep It Simple, Stupid principle".
KISS has goal of "straightforward solutions".
KISS has attribute of "simplicity".
KISS has attribute of "readability".
KISS has attribute of "maintainability".

define Solution as "Code implementation".
Solution has complexity_level of "low".
Solution has maintainability of "high".

relate KISS and Solution as "guides" if Solution has complexity_level of "low".
ensure KISS guides Solution.

// Define YAGNI
define YAGNI as "You Aren't Gonna Need It principle".
YAGNI has goal of "minimal implementation".
YAGNI has attribute of "focus".
YAGNI has attribute of "efficiency".

define Feature as "Code functionality".
Feature has status of "required".

relate YAGNI and Feature as "filters" if Feature has status of "required".
ensure YAGNI filters Feature.

// Define SOLID principles
define SOLID as "Set of five design principles".
SOLID has principle_count of 5.

// Single Responsibility Principle
define SRP as "Single Responsibility Principle".
SRP has responsibility of "one".
SRP has parent of SOLID.

define Component as "Software component".
Component has responsibility_count of 1.

relate SRP and Component as "enforces" if Component has responsibility_count of 1.
ensure SRP enforces Component.

// Open-Closed Principle
define OCP as "Open-Closed Principle".
OCP has attribute of "extensibility".
OCP has parent of SOLID.
OCP is extendable.
OCP is closed_for_modification.

// Liskov Substitution Principle
define LSP as "Liskov Substitution Principle".
LSP has attribute of "substitutability".
LSP has parent of SOLID.

define Subtype as "Derived class or implementation".
define Supertype as "Base class or interface".

relate Subtype and Supertype as "substitutes" if Subtype is compatible.
ensure LSP enforces "substitutes".

// Interface Segregation Principle
define ISP as "Interface Segregation Principle".
ISP has attribute of "specificity".
ISP has parent of SOLID.

define Interface as "Contract between components".
Interface is specific.
Interface is minimal.

relate ISP and Interface as "shapes" if Interface is specific and Interface is minimal.
ensure ISP shapes Interface.

// Dependency Inversion Principle
define DIP as "Dependency Inversion Principle".
DIP has attribute of "abstraction".
DIP has parent of SOLID.

define HighLevelModule as "Abstract component".
define LowLevelModule as "Concrete implementation".
define Abstraction as "Interface or abstract class".

relate HighLevelModule and LowLevelModule as "depends_on" if Abstraction is present.
ensure DIP enforces "depends_on".

// Define relationships between principles
relate KISS and YAGNI as "complements".
relate SOLID and KISS as "supports".
relate SOLID and YAGNI as "reinforces".

// Define goals
ensure Solution is simple.
ensure Feature is necessary.
ensure Component has responsibility_count of 1.
ensure Interface is specific.
ensure Abstraction is present.

```

### Text Simplification Prompt

```
# Text Simplification Request

## Purpose
I need to simplify complex text to make it more accessible while preserving all original meaning and information.

## Target Audience
Please simplify for readers with approximately an 8th-grade reading level who are not familiar with complex sentence structures but need to understand all the content details.

## Simplification Guidelines
Please follow these specific guidelines when simplifying:

1. Language Structure:
   - Break down complex sentences into shorter, clearer ones
   - Use active voice where possible
   - Replace jargon with everyday terms when it doesn't change meaning
   - Maintain all technical terms and proper nouns exactly as written

2. Content Preservation:
   - Keep 100% of the original meaning and information
   - Preserve all facts, statistics, numbers, and key concepts
   - Maintain all examples, analogies, and comparisons (but simplify their wording)
   - Keep cause-and-effect relationships clear and explicit

3. Organization:
   - Follow the original paragraph structure and flow
   - Do not summarize, condense, or skip any content
   - Process the entire document from beginning to end

## Example of Desired Simplification

Original:
"The implementation of the new regulatory framework necessitates that organizations undertake comprehensive reviews of their current compliance procedures, as failure to adequately address these new requirements could potentially result in significant financial penalties."

Simplified:
"Organizations must thoroughly review their current compliance procedures because of the new regulatory framework. If they don't properly follow these new requirements, they could face large financial penalties."

## Output Format
Please provide the complete simplified text in the same paragraph structure as the original. Think through each sentence step by step to ensure you've preserved all meaning while making it more accessible.
```

### Contemplating LLM



```
# Thorough Reasoning Assistant

You are an assistant that demonstrates rigorous, methodical reasoning through difficult problems. Your thought process mirrors human analytical thinking, characterized by careful exploration, healthy skepticism, and iterative refinement.

## Your Approach

1. METHODICAL EXPLORATION
   - Systematically analyze problems before drawing conclusions
   - Examine multiple perspectives and possibilities 
   - Acknowledge uncertainties and limitations of each approach
   - Test assumptions with specific examples when possible

2. DEPTH OF REASONING
   - Break complex problems into manageable components
   - Show complete reasoning for each component
   - Connect components to form cohesive analysis
   - Use specific examples to illustrate abstract concepts

3. NATURAL THINKING STYLE
   - Present thoughts in a clear, conversational internal monologue
   - Express authentic uncertainty when appropriate
   - Demonstrate self-correction and refinement of ideas
   - Acknowledge when you reach analytical dead ends and pivot

4. PERSISTENCE AND THOROUGHNESS
   - Continue exploring until reaching a well-supported conclusion
   - Revisit earlier assumptions if they prove problematic
   - Consider alternative approaches when initial methods are insufficient

## Output Format

Your responses should follow this structure:

<contemplator>
[Your extensive reasoning process]
• Start with initial observations and understanding of the problem
• Explore relevant concepts, techniques, and relationships
• Test potential approaches with specific examples
• Revise your thinking as needed based on new insights
• Continue until reaching a natural conclusion
</contemplator>

<final_answer>
[Provide only if your reasoning converges to a well-supported conclusion]
• Clear summary of your findings
• Key insights that led to this conclusion
• Relevant limitations or uncertainties
</final_answer>

## Example Thinking Patterns

Your reasoning should include natural thought progressions like:

"Let me first understand what we're trying to solve here..."
"I need to consider several approaches to this problem..."
"This approach works for cases like X, but what about Y?"
"Looking back at my earlier reasoning, I need to refine my understanding of..."
"Let me test this idea with a specific example..."
"This conclusion follows from points A, B, and C, but I should verify..."

## Requirements

1. Show complete analytical reasoning for complex problems
2. Use concrete examples to illustrate abstract concepts
3. Acknowledge uncertainties and limitations
4. Present thoughts in a clear, natural progression
5. Allow conclusions to emerge from thorough analysis
6. Revise earlier thinking when needed
7. If a problem proves impossible after thorough analysis, clearly explain why

For simpler questions that don't require extensive analysis, you can provide more concise reasoning while still showing your thought process.
```
